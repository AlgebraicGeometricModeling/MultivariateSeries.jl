var documenterSearchIndex = {"docs":
[{"location":"code/3.decompose/#Decomposition","page":"Decomposition","title":"Decomposition","text":"Pages = [\"3.decompose.md\"]","category":"section"},{"location":"code/3.decompose/#MultivariateSeries.diagonalization","page":"Decomposition","title":"MultivariateSeries.diagonalization","text":"Xi, E, Info =  diagonalization(M::Vector{Matrix{C}}, Info::Dict{String,Any})\n\nCompute the joint diagonalizaion of the matrice in M (assuming it exists). It outputs\n\n- `Xi` the diagonals row by row, the ith row for the matrix  `M[i]`\n- `E`  the matrix of common eigenvectors so that `M[i] = E*diagm(Xi[i,:])*inv(E)`\n\n\n\n\n\n","category":"function"},{"location":"code/3.decompose/#MultivariateSeries.decompose","page":"Decomposition","title":"MultivariateSeries.decompose","text":"decompose(σ :: Series{C,M}, rkf :: Function)\n\nDecompose the series σ as a weighted sum of exponentials. Return ω, Ξ where\n\nω is the vector of weights,\nΞ is the matrix of frequency points, stored per row.\n\nThe list of monomials of degree leq d-1 over 2 are used to construct the Hankel matrix, where d is the maximal degree of the moments in σ.\n\nThe optional argument rkf is the rank function used to determine the numerical rank from the vector S of singular values. Its default value eps_rkf(1.e-6) determines the rank as the first i s.t. S[i+1]/S[i]< 1.e-6 where S is the vector of singular values.\n\nIf the rank function cst_rkf(r) is used, the SVD is truncated at rank r.\n\n\n\n\n\n","category":"function"},{"location":"code/3.functions/#Functions-for-series","page":"Functions for series","title":"Functions for series","text":"","category":"section"},{"location":"code/3.functions/#MultivariateSeries.prodset","page":"Functions for series","title":"MultivariateSeries.prodset","text":"prodsect(X,Y)\n\nProduct-wise vector of X by Y ordered by row with no repetition:      if xiyj appears as xi'yj' with i'<i or i'=i and j'<j it is not inserted.\n\n\n\n\n\n","category":"function"},{"location":"code/3.functions/#MultivariateSeries.prodvec","page":"Functions for series","title":"MultivariateSeries.prodvec","text":"prodvec(X,Y)\n\nProduct-wise vector of X by Y ordered by row: [x1y1, x1y2, ..., x2*y1, ....] \n\n\n\n\n\n","category":"function"},{"location":"code/3.functions/#MultivariateSeries.integrate","page":"Functions for series","title":"MultivariateSeries.integrate","text":"Compute the primitive int_v s = v^-1*s\n\n\n\n\n\nCompute the truncated primitive ``\\int{x{i}} s{| x{i+1}=0, ...x_n=0}''\n\n\n\n\n\n","category":"function"},{"location":"code/3.functions/#MultivariateSeries.matrixof","page":"Functions for series","title":"MultivariateSeries.matrixof","text":"matrixof(P::Vector,L::Vector)\n\nmatrix M which rows are the coefficient the polynomials in P with respect to the monomial vector L, so that M*L=P \n\n\n\n\n\n","category":"function"},{"location":"expl/6.Decoding/#Decoding-algebraic-codes-(BMS)","page":"Decoding algebraic codes (BMS)","title":"Decoding algebraic codes (BMS)","text":"We consider the code C formed by the words min mathbbk^l such that  <center> mf(P_1) ldots f(P_l)=0 </center> where fin Vsubset mathbbkx_1x_n.\n\nusing DynamicPolynomials, MultivariateSeries\nX = @polyvar x1 x2\n\n(x1, x2)\n\nWe consider the following points P and the vector space V spanned by the monomials M of degree le 2 in two variables x_1 x_2.\n\nP = [\n1   1;\n1  -1;\n-1  1;\n-1 -1;\n0   1; \n2  -1;\n1   2;\n1  -2]'\n\nM = monomials(X,0:2)\n\n6-element MonomialVector{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}:\n 1\n x2\n x1\n x2²\n x1x2\n x1²\n\nThe words of the code are the kernel of the following matrix:\n\nfunction vdm(P,L)\n    [ (L[j]+0)(P[:,i])\n        for  j in 1:length(L),i in 1:size(P,2) ]\nend\nW = vdm(P,M)\n\n6×8 Matrix{Int64}:\n 1   1   1   1  1   1  1   1\n 1  -1   1  -1  1  -1  2  -2\n 1   1  -1  -1  0   2  1   1\n 1   1   1   1  1   1  4   4\n 1  -1  -1   1  0  -2  2  -2\n 1   1   1   1  0   4  1   1\n\nWe receive the following word:\n\nr = [3, 3, 3, 0, -6, -2, 0, -1]\n\n8-element Vector{Int64}:\n  3\n  3\n  3\n  0\n -6\n -2\n  0\n -1\n\nIt is not a word of the code C, since the following vector of syndroms is not zero:\n\ns = W*r\n\n6-element Vector{Int64}:\n  0\n  1\n -2\n -3\n  3\n  0\n\nWe want to correct it. For that, we build the corresponding series of syndroms:\n\nsigma = dual(M'*s)\n\ndx2 - 2dx1 - 3dx2^2 + 3dx1*dx2\n\nThe Hankel matrix of sigma in degree le 1 is:\n\nL1 = monomials(X,0:1)\nH = hankel(sigma, L1, L1)\n\n3×3 Matrix{Int64}:\n  0   1  -2\n  1  -3   3\n -2   3   0\n\nAn element in its kernel gives an error locator polynomial of degree 1:\n\nusing LinearAlgebra\nle = nullspace(H); le/=le[3]\nple = dot(L1,le)\n\n$ 2.9999999999999987 + 1.9999999999999984x2 + x1 $\n\nWe check for which point in P, this polynomial vanishes. This will give the position where an error occurs:\n\ner = [subs(ple,x1=>P[1,k], x2=>P[2,k]) for  k in 1:size(P,2)]\n\n8-element Vector{Polynomial{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}, Float64}}:\n 5.999999999999997\n 2.0\n 3.9999999999999973\n 2.220446049250313e-16\n 4.999999999999997\n 3.0\n 7.999999999999996\n 1.7763568394002505e-15\n\nie = []\nfor i in 1:length(er)\n    if isapprox(er[i],0.0;atol=1e-10) push!(ie, i) end\nend\nie\n\n2-element Vector{Any}:\n 4\n 8\n\nThese are the following points of P:\n\nE = hcat([P[:,ie[i]] for i in 1:length(ie)]...)\n\n2×2 Matrix{Int64}:\n -1   1\n -1  -2\n\nTo get the error, that is the weights, we solve the system: E*omega =sigma_x_1 sigma_x_2:\n\ncr = E\\(W*r)[2:3]\n\n2-element Vector{Float64}:\n -0.0\n  1.0\n\nWe can now correct the received message by removing the weights cr at the positions of the errors ie:\n\nc=copy(r)\nfor i in 1:length(ie) c[ie[i]]-= cr[i] end \nc\n\n8-element Vector{Int64}:\n  3\n  3\n  3\n  0\n -6\n -2\n  0\n -2\n\nWe check that the corrected message is a word of the code:\n\nW*c\n\n6-element Vector{Int64}:\n -1\n  3\n -3\n -7\n  5\n -1\n\n","category":"section"},{"location":"expl/4.DiracMeasure/#Weighted-sum-of-Dirac-Measures","page":"Weighted sum of Dirac Measures","title":"Weighted sum of Dirac Measures","text":"using DynamicPolynomials, MultivariateSeries\n\nSeries with 3 variables\n\nx = @polyvar x1 x2 x3\nn = length(x)\nr = 4;\n\nRandom weights in 01\n\nw0 = rand(Float64,r)\n\n4-element Vector{Float64}:\n 0.46545963898811915\n 0.021978038390889187\n 0.04877312766629227\n 0.1370341036362387\n\nRandom points in 01^n\n\nXi0 = rand(Float64,n,r)\n\n3×4 Matrix{Float64}:\n 0.37808   0.231761  0.794831  0.0190203\n 0.621472  0.149643  0.162051  0.623349\n 0.85187   0.715274  0.039446  0.961319\n\nMoment function of the sum of the Dirac measures of the points Xi_0 with weights omega_0 and its generating series up to degree 3.\n\nmt = moment(w0, Xi0)\ns = series(mt, monomials(x, 0:3))\n\n0.6732449086815393 + 0.22244747548801583dx1 + 0.3858826556686884dx2 + 0.5458888158350238dx3 + 0.09857770553712933dx1^2 + 0.11803628307639027dx1*dx2 + 0.15759110449457098dx1*dx3 + 0.23479256902151965dx2^2 + 0.3312005626490396dx2*dx3 + 0.4757340405356967dx3^2 + 0.049920949492184286dx1^3 + 0.04655035411064641dx1^2dx2 + 0.05878658405010533dx1^2dx3 + 0.07011345415830575dx1*dx2^2 + 0.09552151593531152dx1*dx2*dx3 + 0.13278137141780286dx1*dx3^2 + 0.14519624175782025dx2^3 + 0.2047327416078236dx2^2dx3 + 0.29055270964631225dx2*dx3^2 + 0.41752635290304874dx3^3\n\nDecomposition of the series from its terms up to degree 3.\n\nw, Xi = decompose(s);\n\nw\n\n4-element Vector{Float64}:\n 0.1370341036362443\n 0.4654596389880742\n 0.021978038390932233\n 0.04877312766629078\n\nXi\n\n3×4 Matrix{Float64}:\n 0.0190203  0.37808   0.231761  0.794831\n 0.623349   0.621472  0.149643  0.162051\n 0.961319   0.85187   0.715274  0.039446\n\n","category":"section"},{"location":"code/2.polynomials/#Polynomials","page":"Polynomials","title":"Polynomials","text":"Pages = [\"2.polynomials.md\"]","category":"section"},{"location":"code/2.polynomials/#Base.Math.exponent","page":"Polynomials","title":"Base.Math.exponent","text":"exponent(m::Monomial) -> Array{Int64,1}\n\nGet the exponent of a monomial as an array of Int64\n\n\n\n\n\n","category":"function"},{"location":"code/2.polynomials/#Base.inv","page":"Polynomials","title":"Base.inv","text":"inv(m :: Monomial)\n\nreturn the inverse monomial with opposite exponents.\n\n\n\n\n\n inv(m :: Monomial{true})\n\nreturn the inverse monomial with opposite exponents.\n\n\n\n\n\n","category":"function"},{"location":"code/2.polynomials/#MultivariateSeries.sparse_pol","page":"Polynomials","title":"MultivariateSeries.sparse_pol","text":"sparse_pol(w, E, X) -> Polynomial{true,C}\n\nCompute the polynomial  ωᵢ X^Ei with coefficients ωᵢ and monomial exponents Ei.\n\n\n\n\n\n","category":"function"},{"location":"code/2.polynomials/#Base.binomial","page":"Polynomials","title":"Base.binomial","text":"binomial(p::Polynomial) -> Series{C}\n\nMulti-index bonomial coefficients.\n\n\n\n\n\n","category":"function"},{"location":"expl/3.MultivariateProny/#Multivariate-exponential-decompositon","page":"Multivariate exponential decompositon","title":"Multivariate exponential decompositon","text":"using DynamicPolynomials, MultivariateSeries\n\nWe consider the following function, which is a sum of 6 complex exponentials \n\nf = (u,v) -> 0.5*cos(0.7*pi*(u+v))+0.6*sin(4*pi*u)-0.2*cos(pi*v);\n\n(Image: waves)\n\nIn order to recover the frequencies or exponents of these exponential terms and their coefficients, we sample the function on a grid (alpha_1 over T alpha_2 over T) alpha=(alpha_1alpha_2)in Asubset mathbbN^2. This defines a sequence of moments sigma_alpha=f(alpha_1 over T alpha_2 over T). We compute its generating series truncated in degree leq 5.\n\nX = @polyvar x1 x2\nL = monomials(X,0:5)\nT = 10\nmnt = (V->f(V[1]/T,V[2]/T))\nsigma = series(mnt, L)\n\n0.3 + 0.8585922907464658dx1 + 0.29774707771034303dx2 + 0.6050846776084937dx1^2 + 0.8328361327510712dx1*dx2 + 0.2906101273580203dx2^2 - 0.15759364518763863dx1^3 + 0.5575373543042985dx1^2dx2 + 0.8039080170899477dx1*dx2^2 + 0.2775204557293506dx2^3 - 0.4519219149027473dx1^4 - 0.22417045976016967dx1^3dx2 + 0.5095797473748392dx1^2dx2^2 + 0.7717888541929423dx1*dx2^3 + 0.2569085959993554dx2^4 + 0.02699524986977328dx1^5 - 0.5338499631663495dx1^4dx2 - 0.2874793003806999dx1^3dx2^2 + 0.46210935078676274dx1^2dx2^3 + 0.7358257607718759dx1*dx2^4 + 0.22699524986977343dx2^5\n\nComputing its decomposition using svd\n\nw, Xi = decompose(sigma);\n\nyields the weights omega of the exponential terms in f and the exponentials Xi:\n\nlog.(Xi')*T/pi\n\n6×2 Matrix{ComplexF64}:\n  8.54995e-14+4.0im          -2.74234e-13+3.49925e-13im\n  8.66701e-14-4.0im          -2.73528e-13-3.49932e-13im\n -8.03348e-12+0.7im          -6.03198e-12+0.7im\n -8.03216e-12-0.7im          -6.02904e-12-0.7im\n  1.54533e-11+1.54104e-11im   8.86233e-12-1.0im\n   1.5454e-11-1.541e-11im     8.86133e-12+1.0im\n\nBy taking the log and scaling by Tover pi, we recover the frequency vectors within precision 1O^-11. \n\nw\n\n6-element Vector{ComplexF64}:\n 2.7501205230436507e-15 + 0.29999999999998295im\n 2.1890339292793378e-15 - 0.29999999999998267im\n    0.24999999999973513 + 1.1959663390382177e-11im\n    0.24999999999973493 - 1.195958012365533e-11im\n   -0.09999999999895023 - 6.168820123541792e-13im\n   -0.09999999999895037 + 6.168330698883567e-13im\n\n","category":"section"},{"location":"code/1.series/#Series","page":"Series","title":"Series","text":"Pages = [\"1.series.md\"]","category":"section"},{"location":"code/1.series/#MultivariateSeries.Series","page":"Series","title":"MultivariateSeries.Series","text":"Series{C,M}\n\nClass representing multivariate series. The series is a dictionary, which associates values of type C to monomials of type M.\n\n\n\n\n\n","category":"type"},{"location":"code/1.series/#MultivariateSeries.series","page":"Series","title":"MultivariateSeries.series","text":"Construct the series with the term (c,m).\n\n\n\n\n\n    series(t::OrderedDict{M,C})\n\nConstruct the series from the OrderedDict t.\n\n\n\n\n\n    series(m::AbstractVector, c::AbstractVector)\n\nConstruct the series with the vectors of monomials m and coefficients c.\n\n\n\n\n\nConstruct the series from an array of pairs  m=>c where m is a monomial and c the associate coefficient.\n\n\n\n\n\nseries(f::Function, L::Vector{M}) -> Series{C,M}\n\nCompute the generating series sum_x^α in L f(α) z^α for a function  f mathbbN^n rightarrow C and a sequence L of monomials.\n\n\n\n\n\nseries(w:: Vector{C}, P::Matrix{C}, L::Vector{M}) -> Series{C,M}\n\nCompute the series of the moment sequence _i ω_i P_i^α for α in L.\n\n\n\n\n\nseries(w::AbstractVector, P::AbstractMatrix, X, d::Int64) -> Series{C,M}\n\nCompute the series of the moment sequence _i ω_i P_i^α for α leq d.\n\n\n\n\n\nseries(p::Polynomial, zeta, X, d::Int64) -> Series\n\nCompute the series of moments p(ζ^α) for α leq d.\n\n\n\n\n\nseries(H::Matrix{C}, L1::Vector{M}, L2::Vector{M}) -> Series{C,M}\n\nCompute the series associated to the Hankel matrix H, with rows (resp. columns) indexed by the array of monomials L1 (resp. L2).\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#MultivariateSeries.dual","page":"Series","title":"MultivariateSeries.dual","text":"dual(p::Polynomial) -> Series{C}\n\nCompute the series associated to the polynomial p, replacing the variables xi by their dual variables dxi. C is the type of coefficients  of the polynomial p and M its type of monomials.\n\n\n\n\n\n\"\n\ndual(p::AbstractPolynomial, d:: Int64) -> Series{C}\n\nCompute the series associated to the tensor p in degree d, using the apolar product. The coefficients are of type C, which is the promoted type between the type of the coefficients of p and Rational{Int}. The coefficients of the monomials m of  p are divided by the binomial(d, exponents(m)).\n\n\n\n\n\nRecover the polynomial from the series by duality.\n\n\n\n\n\nRecover the polynomial from the series, using the apolar duality i.e. multiplying the coefficients by a binomial.\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#MultivariateSeries.moment","page":"Series","title":"MultivariateSeries.moment","text":"moment(w::Vector{C}, P::Matrix{C}) -> Vector{Int64} -> C\n\nCompute the moment function α - _i ω_i P_i^α associated to the sequence P of r points of dimension n, which is a matrix of size r*n and the weights w.\n\n\n\n\n\nmoment(p::Polynomial, zeta::Vector{C}) -> Vector{Int64} -> C\n\nCompute the moment function α rightarrow p(ζ^α).\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#MultivariateSeries.series_from_apolar","page":"Series","title":"MultivariateSeries.series_from_apolar","text":"  s = series_from_apolar(F, X0, rescaling = 1, d = maxdegree(F))\n\nCompute the series from the apolar dual of the form F in degree d, setting X0=>1 and rescalling the other variables X[i] => X[i]/rescaling\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#MultivariateSeries.scale","page":"Series","title":"MultivariateSeries.scale","text":"scale(σ,λ)\n\nScale the moments σ_α by λ^deg(α).\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#MultivariateSeries.scale!","page":"Series","title":"MultivariateSeries.scale!","text":"scale!(σ,λ)\n\nScale the moments σ_α by λ^deg(α), overwriting σ\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#Base.:*","page":"Series","title":"Base.:*","text":"Multiply the elements of L by the variable v\n\n\n\n\n\n *(v::Variable,   σ::Series{C,M}) -> Series{C,M}\n *(m::Monomial,   σ::Series{C,M}) -> Series{C,M}\n *(t::Term,       σ::Series{C,M}) -> Series{C,M}\n *(p::Polynomial, σ::Series{C,M}) -> Series{C,M}\n\nThe dual product (or co-product) where variables are inverted in the polynomial and the monomials with positive exponents are kept in the series.\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#Base.:&","page":"Series","title":"Base.:&","text":"Term-wise product of series s by p. All the terms of s are multiplied by p            If σ = ∑ σm m, s & p = ∑m (σ_m*p) m\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#LinearAlgebra.dot","page":"Series","title":"LinearAlgebra.dot","text":"dot(σ::Series{C,M}, p::Variable) -> C\ndot(σ::Series{C,M}, p::Monomial) -> C\ndot(σ::Series{C,M}, p::Term) -> C\ndot(σ::Series{C,M}, p::Polynomial) -> C\ndot(σ::Series{C,M}, p::Polynomial, q::Polynomial) -> C\n\nCompute the dot product  p q _σ =  σ  p q  or   σ  p  for p, q polynomials, terms or monomials. Apply the linear functional sigma on monomials, terms, polynomials\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#Base.:|","page":"Series","title":"Base.:|","text":"Apply the linear functional sigma to p.\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#MultivariatePolynomials.maxdegree","page":"Series","title":"MultivariatePolynomials.maxdegree","text":"maxdegree(σ::Series) -> Int64\n\nMaximal degree of the monomials of the moments of the series σ.\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#MultivariateSeries.hankel","page":"Series","title":"MultivariateSeries.hankel","text":"hankel(σ::Series{C,M}, L1::Vector{M}, L2::Vector{M}) -> Array{C,2}\n\nHankel matrix of σ with the rows indexed by the list of polynomials L1 and the columns by L2. The entries are the dot product for σ of the corresponding elements in L1 and L2.\n\nExample\n\njulia> L =[1, x1, x2, x1^2, x1*x2, x2^2]\n\njulia> H = hankel(s,L,L)\n6x6 Array{Float64,2}:\n  4.0   5.0   7.0    5.0  11.0  13.0\n  5.0   5.0  11.0   -1.0  17.0  23.0\n  7.0  11.0  13.0   17.0  23.0  25.0\n  5.0  -1.0  17.0  -31.0  23.0  41.0\n 11.0  17.0  23.0   23.0  41.0  47.0\n 13.0  23.0  25.0   41.0  47.0  49.0\n\n\n\n\n\n","category":"function"},{"location":"code/1.series/#MultivariateSeries.hankelbasis","page":"Series","title":"MultivariateSeries.hankelbasis","text":"Generate the table of Hankel matrices H_α associated to the monomials x^α generating the space of Hankel matrices indexed by L1 (for the rows) and L2 (for the columns).\n\n\n\n\n\n","category":"function"},{"location":"expl/0.Decomposition/#Decomposition-algorithm","page":"Decomposition algorithm","title":"Decomposition algorithm","text":"using DynamicPolynomials, MultivariateSeries, LinearAlgebra\nX = @polyvar x1 x2 x3\n\n(x1, x2, x3)\n\nWe want to find a sparse representation of the following series known up to degree 3:\n\nsigma = dual(6.0 + 4.0*x1 + 15.0*x2 + 6.0*x3 + 6.0*x1^2 + 20.0*x1*x2 + 4.0*x1*x3 + 43.0*x2^2 + 15.0*x2*x3 + 6.0*x3^2 - 26.0*x1^3 + 30.0*x1^2*x2 + 6.0*x1^2*x3 + 72.0*x1*x2^2 + 20.0*x1*x2*x3 + 4.0*x1*x3^2 + 129.0*x2^3 + 43.0*x2^2*x3 + 15.0*x2*x3^2 + 6.0*x3^3)\n\n6.0 + 6.0dx3 + 15.0dx2 + 4.0dx1 + 6.0dx3^2 + 15.0dx2*dx3 + 43.0dx2^2 + 4.0dx1*dx3 + 20.0dx1*dx2 + 6.0dx1^2 + 6.0dx3^3 + 15.0dx2*dx3^2 + 43.0dx2^2dx3 + 129.0dx2^3 + 4.0dx1*dx3^2 + 20.0dx1*dx2*dx3 + 72.0dx1*dx2^2 + 6.0dx1^2dx3 + 30.0dx1^2dx2 - 26.0dx1^3\n\nL1 = monomials(X,0:1)\nL2 = monomials(X,0:2)\n\n10-element MonomialVector{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}:\n 1\n x3\n x2\n x1\n x3²\n x2x3\n x2²\n x1x3\n x1x2\n x1²\n\nH = hankel(sigma,L1,L2)\n\n4×10 Matrix{Float64}:\n  6.0   6.0  15.0   4.0   6.0  15.0   43.0   4.0  20.0    6.0\n  6.0   6.0  15.0   4.0   6.0  15.0   43.0   4.0  20.0    6.0\n 15.0  15.0  43.0  20.0  15.0  43.0  129.0  20.0  72.0   30.0\n  4.0   4.0  20.0   6.0   4.0  20.0   72.0   6.0  30.0  -26.0\n\nThe rank of H_sigma will give us an idea on the dimension of mathcalA_sigma.\n\nrank(H)\n\n3\n\nWe check that 1 x_1 x_2 is a basis of mathcalA_sigma: \n\nB0 = L1[1:3]\n\n3-element MonomialVector{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}:\n 1\n x3\n x2\n\nH0 = hankel(sigma, B0, B0)\n\n3×3 Matrix{Float64}:\n  6.0   6.0  15.0\n  6.0   6.0  15.0\n 15.0  15.0  43.0\n\nrank(H0)\n\n2\n\nLet us compute the shifted (truncated) Hankel operators.\n\nH1 = hankel(sigma, B0, B0*x1)\nH2 = hankel(sigma, B0, B0*x2)\nH3 = hankel(sigma, B0, B0*x3);\nH  = [H1,H2,H3]\nH[1]\n\n3×3 Matrix{Float64}:\n  4.0   4.0  20.0\n  4.0   4.0  20.0\n 20.0  20.0  72.0\n\nM = [ H0^(-1)*H[i] for i in 1:3 ]\nM[1]\n\nSingularException(2)\n\n\n\nStacktrace:\n\n  [1] checknonsingular\n\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/LinearAlgebra/src/factorization.jl:19 [inlined]\n\n  [2] checknonsingular\n\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/LinearAlgebra/src/factorization.jl:22 [inlined]\n\n  [3] #lu!#170\n\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/LinearAlgebra/src/lu.jl:82 [inlined]\n\n  [4] lu!\n\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/LinearAlgebra/src/lu.jl:80 [inlined]\n\n  [5] #lu#176\n\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/LinearAlgebra/src/lu.jl:299 [inlined]\n\n  [6] lu (repeats 2 times)\n\n    @ /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/LinearAlgebra/src/lu.jl:298 [inlined]\n\n  [7] inv(A::Matrix{Float64})\n\n    @ LinearAlgebra /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/LinearAlgebra/src/dense.jl:917\n\n  [8] literal_pow(#unused#::typeof(^), A::Matrix{Float64}, #unused#::Val{-1})\n\n    @ LinearAlgebra /Applications/Julia-1.9.app/Contents/Resources/julia/share/julia/stdlib/v1.9/LinearAlgebra/src/generic.jl:1068\n\n  [9] (::var\"#3#4\")(i::Int64)\n\n    @ Main ./none:0\n\n [10] iterate\n\n    @ ./generator.jl:47 [inlined]\n\n [11] collect(itr::Base.Generator{UnitRange{Int64}, var\"#3#4\"})\n\n    @ Base ./array.jl:782\n\n [12] top-level scope\n\n    @ In[10]:1\n\nThe eigenvalues and eigenvectors of M_x_1 are\n\nWe deduce the operators of multiplication by the variables in the basis B_0:\n\nv, E = eigen(M[1])\n\nUndefVarError: `M` not defined\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ In[11]:1\n\nThe matrices M_x_i are diagonal in this basis:\n\nD = [E^(-1)*M[i]*E for i in 1:3]\nD[1]\n\nUndefVarError: `E` not defined\n\n\n\nStacktrace:\n\n [1] (::var\"#5#6\")(i::Int64)\n\n   @ Main ./none:0\n\n [2] iterate\n\n   @ ./generator.jl:47 [inlined]\n\n [3] collect(itr::Base.Generator{UnitRange{Int64}, var\"#5#6\"})\n\n   @ Base ./array.jl:782\n\n [4] top-level scope\n\n   @ In[12]:1\n\nD[2]\n\nUndefVarError: `D` not defined\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ In[13]:1\n\nD[3]\n\nUndefVarError: `D` not defined\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ In[14]:1\n\nLooking at the corresponding terms on the diagonal, we get the coordinates of the points Xi:\n\nXi = [ D[i][j,j] for i in 1:3, j in 1:3]\n\nUndefVarError: `D` not defined\n\n\n\nStacktrace:\n\n [1] (::var\"#7#8\")(::Tuple{Int64, Int64})\n\n   @ Main ./none:0\n\n [2] iterate\n\n   @ ./generator.jl:47 [inlined]\n\n [3] collect(itr::Base.Generator{Base.Iterators.ProductIterator{Tuple{UnitRange{Int64}, UnitRange{Int64}}}, var\"#7#8\"})\n\n   @ Base ./array.jl:782\n\n [4] top-level scope\n\n   @ In[15]:1\n\nWe normalize the eigenvectors by v_i over v_i(xi_i) and get the interpolation polynomials at the points xi_i:\n\nDg = E'*vcat(fill(1.,1,3), Xi[1:2,:])\nE = E*Dg^(-1)\nU = E'*B0\n\nUndefVarError: `E` not defined\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ In[16]:1\n\nWe deduce the weights w_i=sigma(u_i):\n\nw = hankel(sigma, U, [L1[1]])\n\nUndefVarError: `U` not defined\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ In[17]:1\n\nUsing the command decompose, we can get directly the same decomposition: \n\nw, Xi = decompose(sigma)\n\n([2.0, 5.000000000000065, -1.0000000000000482], [-1.0 1.9999999999999987 4.000000000000004; 1.0 2.9999999999999982 2.0000000000000013; 1.0 1.0 1.0])\n\nXi\n\n3×3 Matrix{Float64}:\n -1.0  2.0  4.0\n  1.0  3.0  2.0\n  1.0  1.0  1.0\n\nw\n\n3-element Vector{Float64}:\n  2.0\n  5.000000000000065\n -1.0000000000000482\n\nThe series decomposes as 2 mathfrake_(-111) + 5 mathfrake_(231) - mathfrake_(421).\n\n","category":"section"},{"location":"#MultivariateSeries","page":"Home","title":"MultivariateSeries","text":"Package for the decomposition of tensors and polynomial-exponential series.","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"The package MultivariateSeries.jl provides tools for the manipulation of sequences (sigma_alpha)_alpha in mathbbK^mathbbN^n indexed by multivariate indices alpha in mathbbN^n which are represented as series: \n\n     sigma(mathbfz) = sum_alpha in mathbbN^n sigma_alpha mathbfy^alpha\n\nThe sequence sigma or the series sigma(y) represents a linear functional on the polynomials:\n\n     sigma p= sum_alpha in mathbbN^n p_alpha mathbfx^alpha mapsto sum_alpha in mathbbN^n p_alpha sigma_alpha\n\nThe series are implemented  as association tables (or dictionnaries) between (a finite set of) monomials and coefficients. They are printed using dual variables dxi=y_i:\n\nusing DynamicPolynomials, MultivariateSeries\nX = @polyvar x1 x2\n\njulia> p = (1+x1)^3 + 0.5*(1+x1+x2)^2\nx1³ + 3.5x1² + x1x2 + 0.5x2² + 4.0x1 + x2 + 1.5\n\njulia> sigma = dual(p)\ndx1^3 + 1.5 + 3.5dx1^2 + 4.0dx1 + dx2 + dx1*dx2 + 0.5dx2^2\n\nSince the series is represented by a table, the order in which the dual monomials are printed is the order used in the table. It is not necessarily sorted by a monomial ordering.\n\njulia> sigma.terms\nDict{Monomial{true},Float64} with 7 entries:\n   x1³  => 1.0\n   1    => 1.5\n   x1²  => 3.5\n   x1   => 4.0\n   x2   => 1.0\n   x1x2 => 1.0\n   x2²  => 0.5\n\nSeries act as linear functionals on polynomials via the dot product:\n\njulia> dot(sigma,x1^2)\n3.5\njulia> dot(sigma,x2^4)\n0.0","category":"section"},{"location":"#Polynomial-exponential-decomposition","page":"Home","title":"Polynomial-exponential decomposition","text":"The package provide tools for solving the following decomposition problem:\n\nGiven (the first terms of) sequence sigma in mathbbK^mathbbN^n or the series  sigma(mathbfy) in mathbbKmathbfy, we want to decompose it as polynomial-exponential series \n\nsigma(mathbfy) = sum_i=1^r omega_i(mathbfy) e^xi_i1 y_1+ cdots + xi_in y_n\n\nwith polynomials omega_i(mathbfy) and points xi_i= (xi_i1 ldots xi_in)in mathbbK^n.  omega_i are called the weights and  xi_i the frequencies of the decomposition.\n\nThese types of decompositions appear in many problems (see Examples). \n\nThe package MultivariateSeries provides functions to manipulate (truncated) series, to construct truncated Hankel matrices, and to compute such a decomposition from these Hankel matrices.","category":"section"},{"location":"#sec_examples","page":"Home","title":"Examples","text":"Pages = map(file -> joinpath(\"expl\", file), filter(x ->endswith(x, \"md\"), readdir(\"expl\")))","category":"section"},{"location":"#Functions-and-types","page":"Home","title":"Functions and types","text":"Pages = map(file -> joinpath(\"code\", file), filter(x ->endswith(x, \"md\"), readdir(\"code\"))) ","category":"section"},{"location":"#sec_installation","page":"Home","title":"Installation","text":"The package is available at https://github.com/AlgebraicGeometricModeling/MultivariateSeries.jl.git\n\nTo install the registered version from Julia:\n\n] add MultivariateSeries\n\nor the last one:\n\n] add https://github.com/AlgebraicGeometricModeling/MultivariateSeries.jl.git\n\nIt can then be used as follows:\n\nusing MultivariateSeries\n\nSee the Examples for more details.","category":"section"},{"location":"expl/5.SparseInterpolation/#Sparse-interpolation","page":"Sparse interpolation","title":"Sparse interpolation","text":"using DynamicPolynomials, MultivariateSeries\n\nA sparse polynomial in 3 variables\n\nX = @polyvar x1 x2 x3\nf = 6.7x1^4*x2^5*x3 + 10.2x1^2*x2*x3^3 - 3.4x1*x2^2*x3\n\n$ 6.7x1^{4}x2^{5}x3 + 10.2x1^{2}x2x3^{3} - 3.4x1x2^{2}x3 $\n\nThe series of moments f(zeta^alpha) for alphaleq 3.\n\nzeta = fill(0.9, length(X))\nsigma = series(f, zeta, X,3)\n\n13.499999999999998 + 9.59787dx1 + 10.382283000000001dx2 + 10.405800000000001dx3 + 6.8223503070000024dx1^2 + 7.5529172763000005dx1*dx2 + 7.225281000000001dx1*dx3 + 8.36740554867dx2^2 + 7.774274700000001dx2*dx3 + 8.093698200000002dx3^2 + 4.834376094422702dx1^3 + 5.495308104980431dx1^2dx2 + 4.995745656300002dx1^2dx3 + 6.217299094482389dx1*dx2^2 + 5.5261037486700015dx1*dx2*dx3 + 5.472820242000002dx1*dx3^2 + 7.008371185034148dx2^3 + 6.117862993803001dx2^2dx3 + 5.852477610000001dx2*dx3^2 + 6.357388987800002dx3^3\n\nComputing its decomposition using svd\n\nw, Xi = decompose(sigma);\n\nyields the coefficients of the terms of f as the weights omega, and the exponents of the monomials of f as the log_zeta of the points Xi:\n\nw\n\n3-element Vector{Float64}:\n 10.200000000000768\n -3.400000000000344\n  6.699999999999744\n\nEx = log(Xi, zeta)\n\n3×3 Matrix{Float64}:\n 2.0  1.0  4.0\n 1.0  2.0  5.0\n 3.0  1.0  1.0\n\n","category":"section"}]
}
